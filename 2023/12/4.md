# 取り組んだ内容一覧
- コードレビューで学ぶ Ruby on Rails

# わかったこと
- 中間テーブルのモデルの命名では、関係構造だけでなく意味も考慮し、関係性を表現することが重要。これによりコードの読みやすさが向上し、同じ関連構造で異なる意味を持つ中間テーブルを作成する際にも困らなくなる。
- 一般ユーザーと管理者が登場する場合、基本的に、一般ユーザーと管理者のモデルを別々にする方が良い。理由は2つ。1つ目は、特定のユーザーを管理者として扱う判定ロジックの誤りによるセキュリティ問題を引き起こしやすいため。2つ目は、 一般ユーザーと管理者では要件が異なることが多いため。一般ユーザーと管理者の要件が異なってくると、他方では使われないカラムやコードが多くなり、同じモデルで管理する意味がなくなってくる。
- default_scope は 使わない方が良い。理由は、default_scope を外したい時に使用する unscope によって意図しないデータにアクセスされる可能性があるため。デフォルトの並び順やスコープを定義する際には、default_scope は使わずに、明示的な命名で scope を作成する。これにより、安全性と可読性が向上する。
- デフォルト値の定義には enumerize という gem の default オプションではなく、Rails 標準の attribute メソッドを使う。enumerize の default オプションを使うと、既存レコードが範囲外の値や NULL の場合でもデフォルト値が適用され、予期しないデータ変更が発生するため。
- マイグレーションファイルの中にモデルのコードを書くのは避けた方が良い。代わりに SQL で更新処理を書くか、メンテナンススクリプトを書く。マイグレーションファイルに書いたモデルのメソッドが将来無くなっているかもしれない。マイグレーションファイルの中でモデルを参照したコードを書くと、マイグレーションが失敗する可能性が高くなる。
- データの整合性を保つために、複数レコードの更新処理はトランザクション(transaction do)で囲むようにすると良い。トランザクションブロック内で例外をスローすることでロールバックされるため、`create` ではなく `create!` として、失敗時には例外を発生させる。トランザクションを使用することで、一連の更新処理がすべて成功するか、すべて失敗するかのどちらかになる。中途半端なレコードが生成されると困る場合は使用した方が良い。ただし、関連レコードを一括で保存する場合は、Rails が自動的にトランザクションを適用するため、明示的なトランザクションの使用は不要。
  ```ruby
  # 関連レコードの一括保存の場合は、トランザクションの使用は不要
  book = Book.new(title: 'test title')
  book.authors.build(name: 'test name')
  book.save
  ```
- なるべく子コンポーネントのルート要素にマージンを持たせるのは避けて、親側で配置するときにマージンを設定する。
- レコードの一覧を表示する際には、order をつけて、順番が必ず固定されるようする。
- テーブル全体から find しなければいけないケースは少ない。params の id などを利用して、不必要に広い範囲から find していると、他のユーザのデータが操作出来てしまいかねない。レコードを取得する際はログインユーザー起点で取得する方が安全。
- 削除は `destroy` ではなく `destroy!` を使う。
- factory bot などの別ファイルに定義したデフォルト値をテストの期待値にすると、分かりにくいテストになる。準備段階で期待値の根拠を示して、テストコード単体で意図を分かりやすくすべき。

# 次やること
- コードレビューで学ぶ Ruby on Rails

# 感じたこと
- 特になし

# 学習時間
Today: 2 h 10 m

Total: 866 h 0 m
